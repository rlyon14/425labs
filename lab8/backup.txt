struct SMPiece fitCnrPiece(int rotation, int column, int depth, unsigned commands) {
	unsigned k;
	unsigned pieceRow0;
	unsigned pieceRow1;
	unsigned arithBase;
	struct SMPiece minSlot;

	failSlot.score = 0xFFFF;
	failSlot.rotation = rotation;
	failSlot.column = column;
	failSlot.commands = 0;
	arithBase = (0x1 << column);
	if (((UsedSlots[rotation]) & arithBase) != 0) { return failSlot; }
	
	if (column < 0) { return failSlot; }
	else if (column > 5) { return failSlot; }
	if (column == 0) {
		if ((rotation == 1)||(rotation == 2)) { return failSlot; }
	}
	if (column == 5) {
		if ((rotation == 0)||(rotation == 3)) { return failSlot; }
	}
	if (rotation > 3) { rotation = 0; }
	else if (rotation < 0) { rotation = 3; }

	//printf("Rotation: %d, Column: %d, Depth: %d\n\r", rotation, column, depth);

	UsedSlots[rotation] = ((UsedSlots[rotation]) | arithBase);

	pieceRow1 = cornerRow1[rotation] >> column;
	pieceRow0 = cornerRow0[rotation] >> column;
	minSlot = failSlot;
	for (k = 0; k <= 6; k++){
		//move up one row and try again
		if ((board[k] & pieceRow0) == pieceRow0) {
			continue;
		}
		//fit
		else if ((board[k] & pieceRow0) == 0) {
			arithBase = k<<8;
			if ((rotation == 2 ) || (rotation == 3)) {
				if ((board[k+1] & pieceRow1) != 0) { break; }
				else if ((board[k] & pieceRow1) == 0) { break; }
			}	
			minSlot.score = arithBase+depth;
			minSlot.rotation = rotation;
			minSlot.column = column;
			minSlot.commands = commands;
			//printf("Score: %#02x\n\r", minSlot.score);
			if (k == 0) { return minSlot; } //maybe don't return here
			else { break; }
		}
		//partial cover --return fail
		else { break; }
	}
	
	if (depth < MAXMOVES) {
		arithBase = commands;
		if (depth > 0) {arithBase = arithBase << 4; }
		depth++;
		tempSlot = fitCnrPiece(rotation, (column-1), depth, (arithBase+1));
		if (tempSlot.score < minSlot.score) { 
			minSlot = tempSlot;
		}
		tempSlot = fitCnrPiece(rotation, (column+1), depth, (arithBase+2));
		if (tempSlot.score < minSlot.score) { 
			minSlot = tempSlot;
		}
		tempSlot = fitCnrPiece((rotation-1), column, depth, (arithBase+3));
		if (tempSlot.score < minSlot.score) { 
			minSlot = tempSlot;
		}
		tempSlot = fitCnrPiece((rotation+1), column, depth, (arithBase+4));
		if (tempSlot.score < minSlot.score) { 
			minSlot = tempSlot;
		}
	}
	return minSlot;	
}
