; Generated by c86 (BYU-NASM) 5.1 (beta) from lab8app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
slotOr:
	DW	0,0,0,3,1
	DW	2,1,3,0,2
slotColumn:
	DW	1,4,0,0,5
	DW	2,2,3,3,5
slotLrow:
	DW	56,7,48,32,3
	DW	8,24,4,6,1
slotUrow:
	DW	0,0,32,48,1
	DW	24,8,6,4,3
L_lab8app_1:
	DB	0xA,0xD,"Game Over!",0xA,0xD,0
	ALIGN	2
SMgameOverHdlr:
	; >>>>> Line:	41
	; >>>>> void SMgameOverHdlr(void){ 
	jmp	L_lab8app_2
L_lab8app_3:
	; >>>>> Line:	42
	; >>>>> printString("\n\rGam 
	mov	ax, L_lab8app_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	43
	; >>>>> exit(0); 
	xor	al, al
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_lab8app_2:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_3
L_lab8app_5:
	DB	0xA,0xD,"PieceQ overflow!",0xA,0xD,0
	ALIGN	2
SMnewpieceHdlr:
	; >>>>> Line:	46
	; >>>>> void SMnewpieceHdlr(void){ 
	jmp	L_lab8app_6
L_lab8app_7:
	; >>>>> Line:	47
	; >>>>> pieceArray[pieceNext].pieceID = NewPieceID; 
	mov	ax, word [pieceNext]
	mov	cx, 3
	shl	ax, cl
	mov	si, ax
	add	si, pieceArray
	mov	ax, word [NewPieceID]
	mov	word [si], ax
	; >>>>> Line:	48
	; >>>>> pieceArray[pieceNext].type = NewPieceType; 
	mov	ax, word [pieceNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieceArray
	mov	si, ax
	add	si, 2
	mov	ax, word [NewPieceType]
	mov	word [si], ax
	; >>>>> Line:	49
	; >>>>> pieceArray[pieceNext].orientation = NewPieceOrientation; 
	mov	ax, word [pieceNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieceArray
	mov	si, ax
	add	si, 4
	mov	ax, word [NewPieceOrientation]
	mov	word [si], ax
	; >>>>> Line:	50
	; >>>>> pieceArray[pieceNext].column = NewPieceColumn; 
	mov	ax, word [pieceNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieceArray
	mov	si, ax
	add	si, 6
	mov	ax, word [NewPieceColumn]
	mov	word [si], ax
	; >>>>> Line:	52
	; >>>>> if (YKQPost(pieceQPtr, (void *) &(pieceArray[pieceNext])) == 0) 
	mov	ax, word [pieceNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, pieceArray
	push	ax
	push	word [pieceQPtr]
	call	YKQPost
	add	sp, 4
	test	ax, ax
	jne	L_lab8app_8
	; >>>>> Line:	53
	; >>>>> printString("\n\rPieceQ overflow!\n\r"); 
	mov	ax, L_lab8app_5
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_9
L_lab8app_8:
	; >>>>> Line:	54
	; >>>>> else if (++pieceNext >= 10) 
	mov	ax, word [pieceNext]
	inc	ax
	mov	word [pieceNext], ax
	cmp	ax, 10
	jb	L_lab8app_10
	; >>>>> Line:	55
	; >>>>> pieceNext = 0; 
	mov	word [pieceNext], 0
L_lab8app_10:
L_lab8app_9:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_6:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_7
	ALIGN	2
SMrecievedCmdHdlr:
	; >>>>> Line:	58
	; >>>>> void SMrecievedCmdHdlr(void){ 
	jmp	L_lab8app_12
L_lab8app_13:
	; >>>>> Line:	59
	; >>>>> YKSemPost(SemPtr); 
	push	word [SemPtr]
	call	YKSemPost
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_lab8app_12:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_13
	ALIGN	2
getCmds:
	; >>>>> Line:	63
	; >>>>> mdNum = cmdNum + (-1*(tmpCmd.slide1)); 
	jmp	L_lab8app_15
L_lab8app_16:
	; >>>>> Line:	68
	; >>>>> rotation = piece->orientation; 
	mov	si, word [bp+4]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-6], ax
	; >>>>> Line:	69
	; >>>>> column = piece->column; 
	mov	si, word [bp+4]
	add	si, 6
	mov	ax, word [si]
	mov	word [bp-4], ax
	; >>>>> Line:	70
	; >>>>> cmdNum = 0; 
	mov	word [bp-2], 0
	; >>>>> Line:	71
	; >>>>> tmpCmd.slide1 = 0; 
	mov	word [(2+tmpCmd)], 0
	; >>>>> Line:	72
	; >>>>> tmpCmd.slide2 = 0; 
	mov	word [(6+tmpCmd)], 0
	; >>>>> Line:	74
	; >>>>> while (rotation != slotOr[slotNum]){ 
	jmp	L_lab8app_18
L_lab8app_17:
	; >>>>> Line:	75
	; >>>>> cmdNum++; 
	inc	word [bp-2]
	; >>>>> Line:	76
	; >>>>> if (rotation == 0) { rotation = 3;} 
	mov	ax, word [bp-6]
	test	ax, ax
	jne	L_lab8app_20
	; >>>>> Line:	76
	; >>>>> if (rotation == 0) { rotation = 3;} 
	mov	word [bp-6], 3
	jmp	L_lab8app_21
L_lab8app_20:
	; >>>>> Line:	77
	; >>>>> else {rotation--;} 
	dec	word [bp-6]
L_lab8app_21:
L_lab8app_18:
	mov	ax, word [bp+6]
	shl	ax, 1
	mov	si, ax
	add	si, slotOr
	mov	ax, word [bp-6]
	cmp	ax, word [si]
	jne	L_lab8app_17
L_lab8app_19:
	; >>>>> Line:	79
	; >>>>> if (cmdNum > 2){ 
	cmp	word [bp-2], 2
	jbe	L_lab8app_22
	; >>>>> Line:	80
	; >>>>> cmdNum = 1; 
	mov	word [bp-2], 1
	; >>>>> Line:	81
	; >>>>> tmpCmd.rotate = -1; 
	mov	word [(4+tmpCmd)], -1
	jmp	L_lab8app_23
L_lab8app_22:
	; >>>>> Line:	84
	; >>>>> tmpCmd.rotate = cmdNum; 
	mov	ax, word [bp-2]
	mov	word [(4+tmpCmd)], ax
L_lab8app_23:
	; >>>>> Line:	87
	; >>>>> tmpCmd.slide2 = 0; 
	mov	word [(6+tmpCmd)], 0
	; >>>>> Line:	88
	; >>>>> tmpCmd.slide1 = (slotColumn[slotNum])-column; 
	mov	ax, word [bp+6]
	shl	ax, 1
	mov	si, ax
	add	si, slotColumn
	mov	ax, word [si]
	sub	ax, word [bp-4]
	mov	word [(2+tmpCmd)], ax
	; >>>>> Line:	89
	; >>>>> if (tmpCmd.slide1 < 0){ 
	cmp	word [(2+tmpCmd)], 0
	jge	L_lab8app_24
	; >>>>> Line:	90
	; >>>>> cmdNum = cmdNum + (-1*(tmpCmd.slide1)); 
	mov	ax, word [(2+tmpCmd)]
	mov	cx, -1
	imul	cx
	add	ax, word [bp-2]
	mov	word [bp-2], ax
	jmp	L_lab8app_25
L_lab8app_24:
	; >>>>> Line:	93
	; >>>>> cmdNum = cmdNum + tmpCmd.slide1; 
	mov	ax, word [(2+tmpCmd)]
	add	ax, word [bp-2]
	mov	word [bp-2], ax
L_lab8app_25:
	; >>>>> Line:	96
	; >>>>> if (tmpCmd.rotate != 0){ 
	mov	ax, word [(4+tmpCmd)]
	test	ax, ax
	je	L_lab8app_26
	; >>>>> Line:	97
	; >>>>> if (slotColumn[slotNum] == 0) { 
	mov	ax, word [bp+6]
	shl	ax, 1
	mov	si, ax
	add	si, slotColumn
	mov	ax, word [si]
	test	ax, ax
	jne	L_lab8app_27
	; >>>>> Line:	98
	; >>>>> if (column == 0) { 
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_lab8app_28
	; >>>>> Line:	99
	; >>>>> tmpCmd.slide1 = 1; 
	mov	word [(2+tmpCmd)], 1
	; >>>>> Line:	100
	; >>>>> tmpCmd.slide2 = -1; 
	mov	word [(6+tmpCmd)], -1
	; >>>>> Line:	101
	; >>>>> cmdNum = cmdNum +2; 
	mov	ax, word [bp-2]
	add	ax, 2
	mov	word [bp-2], ax
	jmp	L_lab8app_29
L_lab8app_28:
	; >>>>> Line:	103
	; >>>>> else if (column == 5) { 
	cmp	word [bp-4], 5
	jne	L_lab8app_30
	; >>>>> Line:	104
	; >>>>> tmpCmd.slide1 = -1; 
	mov	word [(2+tmpCmd)], -1
	; >>>>> Line:	105
	; >>>>> tmpCmd.slide2 = -4; 
	mov	word [(6+tmpCmd)], -4
	jmp	L_lab8app_31
L_lab8app_30:
	; >>>>> Line:	109
	; >>>>> tmpCmd.slide2 = tmpCmd.slide1; 
	mov	ax, word [(2+tmpCmd)]
	mov	word [(6+tmpCmd)], ax
	; >>>>> Line:	110
	; >>>>> tmpCmd.slide1 = 0; 
	mov	word [(2+tmpCmd)], 0
L_lab8app_31:
L_lab8app_29:
L_lab8app_27:
	; >>>>> Line:	113
	; >>>>> if (slotColumn[slotNum] == 5) { 
	mov	ax, word [bp+6]
	shl	ax, 1
	mov	si, ax
	add	si, slotColumn
	cmp	word [si], 5
	jne	L_lab8app_32
	; >>>>> Line:	114
	; >>>>> if (column == 0) { 
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_lab8app_33
	; >>>>> Line:	115
	; >>>>> tmpCmd.slide1 = 1; 
	mov	word [(2+tmpCmd)], 1
	; >>>>> Line:	116
	; >>>>> tmpCmd.slide2 = 4; 
	mov	word [(6+tmpCmd)], 4
	jmp	L_lab8app_34
L_lab8app_33:
	; >>>>> Line:	118
	; >>>>> else if (column == 5) { 
	cmp	word [bp-4], 5
	jne	L_lab8app_35
	; >>>>> Line:	119
	; >>>>> tmpCmd.slide1 = - 
	mov	word [(2+tmpCmd)], -1
	; >>>>> Line:	120
	; >>>>> tmpCmd.slide2 = 1; 
	mov	word [(6+tmpCmd)], 1
	; >>>>> Line:	121
	; >>>>> cmdNum = cmdNum +2; 
	mov	ax, word [bp-2]
	add	ax, 2
	mov	word [bp-2], ax
	jmp	L_lab8app_36
L_lab8app_35:
	; >>>>> Line:	125
	; >>>>> tmpCmd.slide2 = tmpCmd.slide1; 
	mov	ax, word [(2+tmpCmd)]
	mov	word [(6+tmpCmd)], ax
	; >>>>> Line:	126
	; >>>>> tmpCmd.slide1 = 0; 
	mov	word [(2+tmpCmd)], 0
L_lab8app_36:
L_lab8app_34:
L_lab8app_32:
L_lab8app_26:
	; >>>>> Line:	131
	; >>>>> return cmdNum; 
	mov	ax, word [bp-2]
L_lab8app_37:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_15:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_lab8app_16
L_lab8app_41:
	DB	0xA,0xD,"cmdQ overflow!",0xA,0xD,0
L_lab8app_40:
	DB	0xA,0xD,"Default hit (corner piece)",0xA,0xD,0
L_lab8app_39:
	DB	0xA,0xD,"Default hit (straight piece)",0xA,0xD,0
	ALIGN	2
SMpieceTask:
	; >>>>> Line:	135
	; >>>>> void SMpieceTask(void) { 
	jmp	L_lab8app_42
L_lab8app_43:
	; >>>>> Line:	143
	; >>>>> SeedSimptris(10947); 
	mov	ax, 10947
	xor	dx, dx
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	; >>>>> Line:	144
	; >>>>> StartSimptris(); 
	call	StartSimptris
	; >>>>> Line:	145
	; >>>>> while(1) { 
	jmp	L_lab8app_45
L_lab8app_44:
	; >>>>> Line:	146
	; >>>>> ptemp = (struct SMpiece*) YKQPend(pieceQPtr); 
	push	word [pieceQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	149
	; >>>>> if (ptemp->type == 1) { 
	mov	si, word [bp-2]
	add	si, 2
	cmp	word [si], 1
	jne	L_lab8app_47
	; >>>>> Line:	150
	; >>>>> if (lowerRow == 0) { 
	mov	ax, word [lowerRow]
	test	ax, ax
	jne	L_lab8app_48
	; >>>>> Line:	151
	; >>>>> tCmdNum = getCmds(ptemp, 0); 
	xor	ax, ax
	push	ax
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	word [bp-10], ax
	; >>>>> Line:	152
	; >>>>> if (getCmds(ptemp, 1) < tCmdN 
	mov	ax, 1
	push	ax
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	dx, word [bp-10]
	cmp	dx, ax
	jle	L_lab8app_49
	; >>>>> Line:	153
	; >>>>> destSlot = 1; 
	mov	word [bp-4], 1
	jmp	L_lab8app_50
L_lab8app_49:
	; >>>>> Line:	156
	; >>>>> destSlot = 0; 
	mov	word [bp-4], 0
L_lab8app_50:
	jmp	L_lab8app_51
L_lab8app_48:
	; >>>>> Line:	159
	; >>>>> else if ((lowerRow & 0x38) == 0) {destSlot = 0;} 
	mov	ax, word [lowerRow]
	and	ax, 56
	jne	L_lab8app_52
	; >>>>> Line:	159
	; >>>>> else if ((lowerRow & 0x38) == 0) {destSlot = 0;} 
	mov	word [bp-4], 0
	jmp	L_lab8app_53
L_lab8app_52:
	; >>>>> Line:	160
	; >>>>> else if ((lowerRow & 0x07) == 0) {destSlot = 1;} 
	mov	ax, word [lowerRow]
	and	ax, 7
	jne	L_lab8app_54
	; >>>>> Line:	160
	; >>>>> else if ((lowerRow & 0x07) == 0) {destSlot = 1;} 
	mov	word [bp-4], 1
	jmp	L_lab8app_55
L_lab8app_54:
	; >>>>> Line:	161
	; >>>>> else if ((lowerRow & 0x38) == 0x38) {destSlot = 0;} 
	mov	ax, word [lowerRow]
	and	ax, 56
	cmp	ax, 56
	jne	L_lab8app_56
	; >>>>> Line:	161
	; >>>>> else if ((lowerRow & 0x38) == 0x38) {destSlot = 0;} 
	mov	word [bp-4], 0
	jmp	L_lab8app_57
L_lab8app_56:
	; >>>>> Line:	162
	; >>>>> else if ((lowerRow & 0x07) == 0x07) {destSlot = 1;} 
	mov	ax, word [lowerRow]
	and	ax, 7
	cmp	ax, 7
	jne	L_lab8app_58
	; >>>>> Line:	162
	; >>>>> else if ((lowerRow & 0x07) == 0x07) {destSlot = 1;} 
	mov	word [bp-4], 1
	jmp	L_lab8app_59
L_lab8app_58:
	; >>>>> Line:	164
	; >>>>> printString("\n\rDefault hit (straight piece)\n\r"); 
	mov	ax, L_lab8app_39
	push	ax
	call	printString
	add	sp, 2
L_lab8app_59:
L_lab8app_57:
L_lab8app_55:
L_lab8app_53:
L_lab8app_51:
	; >>>>> Line:	167
	; >>>>> tCmdNum = getCmds(ptemp, destSlot); 
	push	word [bp-4]
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	word [bp-10], ax
	; >>>>> Line:	170
	; >>>>> if ((upperRow | slotLrow[destSlot]) == upperRow) { 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, slotLrow
	mov	ax, word [si]
	or	ax, word [upperRow]
	mov	dx, word [upperRow]
	cmp	dx, ax
	jne	L_lab8app_60
	; >>>>> Line:	171
	; >>>>> if (destSlot == 0) { leftBlock++; } 
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_lab8app_61
	; >>>>> Line:	171
	; >>>>> if (destSlot == 0) { leftBlock++; } 
	inc	word [leftBlock]
	jmp	L_lab8app_62
L_lab8app_61:
	; >>>>> Line:	172
	; >>>>> mds(ptemp, 4); 
	inc	word [rightBlock]
L_lab8app_62:
	jmp	L_lab8app_63
L_lab8app_60:
	; >>>>> Line:	174
	; >>>>> else if ((lowerRow | slotLrow[destSlot]) == lowerRow) { 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, slotLrow
	mov	ax, word [si]
	or	ax, word [lowerRow]
	mov	dx, word [lowerRow]
	cmp	dx, ax
	jne	L_lab8app_64
	; >>>>> Line:	175
	; >>>>> upperRow = upperRow | slotLrow[destSlot]; 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, slotLrow
	mov	ax, word [si]
	or	ax, word [upperRow]
	mov	word [upperRow], ax
	jmp	L_lab8app_65
L_lab8app_64:
	; >>>>> Line:	178
	; >>>>> lowerRow = lowerRow | slotLrow[destSlot]; 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, slotLrow
	mov	ax, word [si]
	or	ax, word [lowerRow]
	mov	word [lowerRow], ax
L_lab8app_65:
L_lab8app_63:
	jmp	L_lab8app_66
L_lab8app_47:
	; >>>>> Line:	184
	; >>>>> if (lowerRow == 0) { 
	mov	ax, word [lowerRow]
	test	ax, ax
	jne	L_lab8app_67
	; >>>>> Line:	185
	; >>>>> minCmdNum = 20; 
	mov	word [bp-8], 20
	; >>>>> Line:	186
	; >>>>> k = 2; 
	mov	word [bp-14], 2
	; >>>>> Line:	187
	; >>>>> while (k < 5){ 
	jmp	L_lab8app_69
L_lab8app_68:
	; >>>>> Line:	188
	; >>>>> tCmdNum = getCmds(ptemp, k); 
	push	word [bp-14]
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	word [bp-10], ax
	; >>>>> Line:	189
	; >>>>> if (tCmdNum < minCmdNum){ 
	mov	ax, word [bp-8]
	cmp	ax, word [bp-10]
	jle	L_lab8app_71
	; >>>>> Line:	190
	; >>>>> minCmdNum = tCmdNum; 
	mov	ax, word [bp-10]
	mov	word [bp-8], ax
	; >>>>> Line:	191
	; >>>>> minSlot = k; 
	mov	ax, word [bp-14]
	mov	word [bp-6], ax
L_lab8app_71:
	; >>>>> Line:	193
	; >>>>> k = k+2; 
	mov	ax, word [bp-14]
	add	ax, 2
	mov	word [bp-14], ax
L_lab8app_69:
	cmp	word [bp-14], 5
	jl	L_lab8app_68
L_lab8app_70:
	; >>>>> Line:	195
	; >>>>> destSlot = minSlot; 
	mov	ax, word [bp-6]
	mov	word [bp-4], ax
	jmp	L_lab8app_72
L_lab8app_67:
	; >>>>> Line:	197
	; >>>>> else if (lowerRow == 0x38) { 
	cmp	word [lowerRow], 56
	jne	L_lab8app_73
	; >>>>> Line:	198
	; >>>>> tCmdNum = getCmds(ptemp, 4); 
	mov	ax, 4
	push	ax
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	word [bp-10], ax
	; >>>>> Line:	199
	; >>>>> Sl 
	mov	word [bp-4], 4
	jmp	L_lab8app_74
L_lab8app_73:
	; >>>>> Line:	201
	; >>>>> else if (lowerRow == 0x07) { 
	cmp	word [lowerRow], 7
	jne	L_lab8app_75
	; >>>>> Line:	202
	; >>>>> tCmdNum = getCmds(ptemp, 2); 
	mov	ax, 2
	push	ax
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	word [bp-10], ax
	; >>>>> Line:	203
	; >>>>> destSlot = 2; 
	mov	word [bp-4], 2
	jmp	L_lab8app_76
L_lab8app_75:
	; >>>>> Line:	205
	; >>>>> else if ((lowerRow & 0x38) == 0x30) {destSlot = 5;} 
	mov	ax, word [lowerRow]
	and	ax, 56
	cmp	ax, 48
	jne	L_lab8app_77
	; >>>>> Line:	205
	; >>>>> else if ((lowerRow & 0x38) == 0x30) {destSlot = 5;} 
	mov	word [bp-4], 5
	jmp	L_lab8app_78
L_lab8app_77:
	; >>>>> Line:	206
	; >>>>> else if ((lowerRow & 0x07) == 0x03) {destSlot = 7;} 
	mov	ax, word [lowerRow]
	and	ax, 7
	cmp	ax, 3
	jne	L_lab8app_79
	; >>>>> Line:	206
	; >>>>> else if ((lowerRow & 0x07) == 0x03) {destSlot = 7;} 
	mov	word [bp-4], 7
	jmp	L_lab8app_80
L_lab8app_79:
	; >>>>> Line:	207
	; >>>>> else if ((lowerRow & 0x38) == 0x18) {destSlot = 3;} 
	mov	ax, word [lowerRow]
	and	ax, 56
	cmp	ax, 24
	jne	L_lab8app_81
	; >>>>> Line:	207
	; >>>>> else if ((lowerRow & 0x38) == 0x18) {destSlot = 3;} 
	mov	word [bp-4], 3
	jmp	L_lab8app_82
L_lab8app_81:
	; >>>>> Line:	208
	; >>>>> else if ((lowerRow & 0x07) == 0x06) {destSlot = 9;} 
	mov	ax, word [lowerRow]
	and	ax, 7
	cmp	ax, 6
	jne	L_lab8app_83
	; >>>>> Line:	208
	; >>>>> else if ((lowerRow & 0x07) == 0x06) {destSlot = 9;} 
	mov	word [bp-4], 9
	jmp	L_lab8app_84
L_lab8app_83:
	; >>>>> Line:	209
	; >>>>> else { printString("\n\rDefault hit (corner piece)\n\r");} 
	mov	ax, L_lab8app_40
	push	ax
	call	printString
	add	sp, 2
L_lab8app_84:
L_lab8app_82:
L_lab8app_80:
L_lab8app_78:
L_lab8app_76:
L_lab8app_74:
L_lab8app_72:
	; >>>>> Line:	211
	; >>>>> tCmdNum = getCmds(ptemp, destSlot); 
	push	word [bp-4]
	push	word [bp-2]
	call	getCmds
	add	sp, 4
	mov	word [bp-10], ax
	; >>>>> Line:	213
	; >>>>> lowerRow = lowerRow | slotLrow[destSlot]; 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, slotLrow
	mov	ax, word [si]
	or	ax, word [lowerRow]
	mov	word [lowerRow], ax
	; >>>>> Line:	214
	; >>>>> upperRow = upperRow | slotUrow[destSl 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, slotUrow
	mov	ax, word [si]
	or	ax, word [upperRow]
	mov	word [upperRow], ax
L_lab8app_66:
	; >>>>> Line:	217
	; >>>>> for (k = 0; k < 2; k ++) { 
	mov	word [bp-14], 0
	jmp	L_lab8app_86
L_lab8app_85:
	; >>>>> Line:	218
	; >>>>> if (lowerRow == 0x3F) { 
	cmp	word [lowerRow], 63
	jne	L_lab8app_89
	; >>>>> Line:	219
	; >>>>> lowerRow = upperRow; 
	mov	ax, word [upperRow]
	mov	word [lowerRow], ax
	; >>>>> Line:	220
	; >>>>> upperRow = 0; 
	mov	word [upperRow], 0
	; >>>>> Line:	221
	; >>>>> if (rightBlock > 0) { 
	mov	ax, word [rightBlock]
	test	ax, ax
	je	L_lab8app_90
	; >>>>> Line:	222
	; >>>>> rightBlock--; 
	dec	word [rightBlock]
	; >>>>> Line:	223
	; >>>>> upperRow = 0x07; 
	mov	word [upperRow], 7
	jmp	L_lab8app_91
L_lab8app_90:
	; >>>>> Line:	225
	; >>>>> else if (leftBlock > 0) { 
	mov	ax, word [leftBlock]
	test	ax, ax
	je	L_lab8app_92
	; >>>>> Line:	226
	; >>>>> leftBlock--; 
	dec	word [leftBlock]
	; >>>>> Line:	227
	; >>>>> upperRow = 0x38; 
	mov	word [upperRow], 56
L_lab8app_92:
L_lab8app_91:
L_lab8app_89:
L_lab8app_88:
	inc	word [bp-14]
L_lab8app_86:
	cmp	word [bp-14], 2
	jl	L_lab8app_85
L_lab8app_87:
	; >>>>> Line:	231
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	250
	; >>>>> cmdArray[cmdNext].pieceID = ptemp->pieceID; 
	mov	si, word [bp-2]
	mov	ax, word [cmdNext]
	mov	cx, 3
	shl	ax, cl
	mov	di, ax
	add	di, cmdArray
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	251
	; >>>>> cmdArray[cmdNext].slide1 = tmpCmd.slide1; 
	mov	ax, word [cmdNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, cmdArray
	mov	si, ax
	add	si, 2
	mov	ax, word [(2+tmpCmd)]
	mov	word [si], ax
	; >>>>> Line:	252
	; >>>>> cmdArray[cmdNext].rotate = tmpCmd.rotate; 
	mov	ax, word [cmdNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, cmdArray
	mov	si, ax
	add	si, 4
	mov	ax, word [(4+tmpCmd)]
	mov	word [si], ax
	; >>>>> Line:	253
	; >>>>> cmdArray[cmdNext].slide2 = tmpCmd.slide2; 
	mov	ax, word [cmdNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, cmdArray
	mov	si, ax
	add	si, 6
	mov	ax, word [(6+tmpCmd)]
	mov	word [si], ax
	; >>>>> Line:	254
	; >>>>> if (YKQPost(cmdQPtr, (void *) 
	mov	ax, word [cmdNext]
	mov	cx, 3
	shl	ax, cl
	add	ax, cmdArray
	push	ax
	push	word [cmdQPtr]
	call	YKQPost
	add	sp, 4
	test	ax, ax
	jne	L_lab8app_93
	; >>>>> Line:	255
	; >>>>> printString("\n\rcmdQ overflow!\n\r"); 
	mov	ax, L_lab8app_41
	push	ax
	call	printString
	add	sp, 2
	jmp	L_lab8app_94
L_lab8app_93:
	; >>>>> Line:	256
	; >>>>> else if (++cmdNext >= 10) 
	mov	ax, word [cmdNext]
	inc	ax
	mov	word [cmdNext], ax
	cmp	ax, 10
	jb	L_lab8app_95
	; >>>>> Line:	257
	; >>>>> cmdNext = 0; 
	mov	word [cmdNext], 0
L_lab8app_95:
L_lab8app_94:
	; >>>>> Line:	258
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_lab8app_45:
	jmp	L_lab8app_44
L_lab8app_46:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_42:
	push	bp
	mov	bp, sp
	sub	sp, 14
	jmp	L_lab8app_43
	ALIGN	2
SMcmdTask:
	; >>>>> Line:	264
	; >>>>> void SMcmdTask(void) { 
	jmp	L_lab8app_97
L_lab8app_98:
	; >>>>> Line:	270
	; >>>>> while(1) { 
	jmp	L_lab8app_100
L_lab8app_99:
	; >>>>> Line:	271
	; >>>>> ctemp = (struct SMcmd*) YKQPend(cmdQPtr); 
	push	word [cmdQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	272
	; >>>>> if (ctemp->slide1 != 0){ 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_102
	; >>>>> Line:	273
	; >>>>> slide = ctemp->slide1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-6], ax
	; >>>>> Line:	274
	; >>>>> if (slide > 0) {direction = 1;} 
	cmp	word [bp-6], 0
	jle	L_lab8app_103
	; >>>>> Line:	274
	; >>>>> if (slide > 0) {direction = 1;} 
	mov	word [bp-8], 1
	jmp	L_lab8app_104
L_lab8app_103:
	; >>>>> Line:	276
	; >>>>> direction = 0; 
	mov	word [bp-8], 0
	; >>>>> Line:	277
	; >>>>> slide = -1*slide; 
	mov	ax, word [bp-6]
	mov	cx, -1
	imul	cx
	mov	word [bp-6], ax
L_lab8app_104:
	; >>>>> Line:	279
	; >>>>> for (k = 0; k < slide; k++){ 
	mov	word [bp-4], 0
	jmp	L_lab8app_106
L_lab8app_105:
	; >>>>> Line:	280
	; >>>>> YKSemPend(SemPtr); 
	push	word [SemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	281
	; >>>>> SlidePiece(ctemp 
	push	word [bp-8]
	mov	si, word [bp-2]
	push	word [si]
	call	SlidePiece
	add	sp, 4
L_lab8app_108:
	inc	word [bp-4]
L_lab8app_106:
	mov	ax, word [bp-6]
	cmp	ax, word [bp-4]
	jg	L_lab8app_105
L_lab8app_107:
L_lab8app_102:
	; >>>>> Line:	284
	; >>>>> if (ctemp->rotate != 0){ 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_109
	; >>>>> Line:	285
	; >>>>> rotate = ctemp->rotate; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-10], ax
	; >>>>> Line:	286
	; >>>>> if (rotate > 0) {direction = 1;} 
	cmp	word [bp-10], 0
	jle	L_lab8app_110
	; >>>>> Line:	286
	; >>>>> if (rotate > 0) {direction = 1;} 
	mov	word [bp-8], 1
	jmp	L_lab8app_111
L_lab8app_110:
	; >>>>> Line:	288
	; >>>>> direction = 0; 
	mov	word [bp-8], 0
	; >>>>> Line:	289
	; >>>>> rotate = -1*rotate; 
	mov	ax, word [bp-10]
	mov	cx, -1
	imul	cx
	mov	word [bp-10], ax
L_lab8app_111:
	; >>>>> Line:	291
	; >>>>> for (k = 0; k < rotate; k++){ 
	mov	word [bp-4], 0
	jmp	L_lab8app_113
L_lab8app_112:
	; >>>>> Line:	292
	; >>>>> YKSemPend(SemPtr); 
	push	word [SemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	293
	; >>>>> RotatePiece(ctemp->pieceID, direction); 
	push	word [bp-8]
	mov	si, word [bp-2]
	push	word [si]
	call	RotatePiece
	add	sp, 4
L_lab8app_115:
	inc	word [bp-4]
L_lab8app_113:
	mov	ax, word [bp-10]
	cmp	ax, word [bp-4]
	jg	L_lab8app_112
L_lab8app_114:
L_lab8app_109:
	; >>>>> Line:	296
	; >>>>> if (ctemp->slide2 != 0){ 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	test	ax, ax
	je	L_lab8app_116
	; >>>>> Line:	297
	; >>>>> slide = ctemp->slide2; 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	mov	word [bp-6], ax
	; >>>>> Line:	298
	; >>>>> if (slide > 0) {direction = 1;} 
	cmp	word [bp-6], 0
	jle	L_lab8app_117
	; >>>>> Line:	298
	; >>>>> if (slide > 0) {direction = 1;} 
	mov	word [bp-8], 1
	jmp	L_lab8app_118
L_lab8app_117:
	; >>>>> Line:	300
	; >>>>> direction = 0; 
	mov	word [bp-8], 0
	; >>>>> Line:	301
	; >>>>> slide = -1*slide; 
	mov	ax, word [bp-6]
	mov	cx, -1
	imul	cx
	mov	word [bp-6], ax
L_lab8app_118:
	; >>>>> Line:	303
	; >>>>> for (k = 0; k < slide; k++){ 
	mov	word [bp-4], 0
	jmp	L_lab8app_120
L_lab8app_119:
	; >>>>> Line:	304
	; >>>>> YKSemPend(SemPtr); 
	push	word [SemPtr]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	305
	; >>>>> SlidePiece(cte 
	push	word [bp-8]
	mov	si, word [bp-2]
	push	word [si]
	call	SlidePiece
	add	sp, 4
L_lab8app_122:
	inc	word [bp-4]
L_lab8app_120:
	mov	ax, word [bp-6]
	cmp	ax, word [bp-4]
	jg	L_lab8app_119
L_lab8app_121:
L_lab8app_116:
L_lab8app_100:
	jmp	L_lab8app_99
L_lab8app_101:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_97:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_lab8app_98
L_lab8app_128:
	DB	">",0xD,0xA,0
L_lab8app_127:
	DB	", CPU: ",0
L_lab8app_126:
	DB	"<CS: ",0
L_lab8app_125:
	DB	"Determining CPU capacity",0xD,0xA,0
L_lab8app_124:
	DB	"Starting Simtris",0xD,0xA,0
	ALIGN	2
SMStatTask:
	; >>>>> Line:	313
	; >>>>> { 
	jmp	L_lab8app_129
L_lab8app_130:
	; >>>>> Line:	317
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	318
	; >>>>> printString("Starting Simtris\r\n"); 
	mov	ax, L_lab8app_124
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	319
	; >>>>> printString("Determining CPU capacity\r\n"); 
	mov	ax, L_lab8app_125
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	320
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	321
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	322
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	323
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	xor	dx, dx
	mov	cx, 25
	div	cx
	mov	word [bp-2], ax
	; >>>>> Line:	324
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	326
	; >>>>> YKNewTask(SMcmdTask, (void *) &SMcmdTaskStk[512], 1); 
	mov	al, 1
	push	ax
	mov	ax, (SMcmdTaskStk+1024)
	push	ax
	mov	ax, SMcmdTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	327
	; >>>>> YKNewTask(SMpieceTask, (void *) &SMpieceTaskStk[512], 2); 
	mov	al, 2
	push	ax
	mov	ax, (SMpieceTaskStk+1024)
	push	ax
	mov	ax, SMpieceTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	329
	; >>>>> while (1) 
	jmp	L_lab8app_132
L_lab8app_131:
	; >>>>> Line:	331
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	333
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	334
	; >>>>> switchCount = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	335
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	; >>>>> Line:	337
	; >>>>> printString("<CS: "); 
	mov	ax, L_lab8app_126
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	338
	; >>>>> printInt((int)switchCount); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	339
	; >>>>> printString(", CPU: "); 
	mov	ax, L_lab8app_127
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	340
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	; >>>>> Line:	341
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	342
	; >>>>> printString(">\r\n"); 
	mov	ax, L_lab8app_128
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	344
	; >>>>> YKCtxSwCount = 0; 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	345
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	346
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_lab8app_132:
	jmp	L_lab8app_131
L_lab8app_133:
	mov	sp, bp
	pop	bp
	ret
L_lab8app_129:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab8app_130
L_lab8app_135:
	DB	"PSem",0
	ALIGN	2
main:
	; >>>>> Line:	351
	; >>>>> { 
	jmp	L_lab8app_136
L_lab8app_137:
	; >>>>> Line:	352
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	353
	; >>>>> pieceNext = 0; 
	mov	word [pieceNext], 0
	; >>>>> Line:	354
	; >>>>> cmdNext = 0; 
	mov	word [cmdNext], 0
	; >>>>> Line:	355
	; >>>>> rightBlock = 0; 
	mov	word [rightBlock], 0
	; >>>>> Line:	356
	; >>>>> leftBlock = 0; 
	mov	word [leftBlock], 0
	; >>>>> Line:	357
	; >>>>> upperRow = 0; 
	mov	word [upperRow], 0
	; >>>>> Line:	358
	; >>>>> lowerRow = 0; 
	mov	word [lowerRow], 0
	; >>>>> Line:	359
	; >>>>> score = 0; 
	mov	word [score], 0
	; >>>>> Line:	360
	; >>>>>  
	mov	ax, 10
	push	ax
	mov	ax, pieceQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [pieceQPtr], ax
	; >>>>> Line:	361
	; >>>>> cmdQPtr = YKQCreate(cmdQ, 10); 
	mov	ax, 10
	push	ax
	mov	ax, cmdQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [cmdQPtr], ax
	; >>>>> Line:	362
	; >>>>> SemPtr = YKSemCreate(1, "PSem"); 
	mov	ax, L_lab8app_135
	push	ax
	mov	ax, 1
	push	ax
	call	YKSemCreate
	add	sp, 4
	mov	word [SemPtr], ax
	; >>>>> Line:	363
	; >>>>> YKNewTask(SMStatTask, (void *) &SMStatTaskStk[512], 0); 
	xor	al, al
	push	ax
	mov	ax, (SMStatTaskStk+1024)
	push	ax
	mov	ax, SMStatTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	364
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab8app_136:
	push	bp
	mov	bp, sp
	jmp	L_lab8app_137
	ALIGN	2
pieceArray:
	TIMES	80 db 0
cmdArray:
	TIMES	80 db 0
pieceQ:
	TIMES	20 db 0
cmdQ:
	TIMES	20 db 0
pieceQPtr:
	TIMES	2 db 0
cmdQPtr:
	TIMES	2 db 0
SemPtr:
	TIMES	2 db 0
SMcmdTaskStk:
	TIMES	1024 db 0
SMpieceTaskStk:
	TIMES	1024 db 0
SMStatTaskStk:
	TIMES	1024 db 0
rightBlock:
	TIMES	2 db 0
leftBlock:
	TIMES	2 db 0
upperRow:
	TIMES	2 db 0
lowerRow:
	TIMES	2 db 0
pieceNext:
	TIMES	2 db 0
cmdNext:
	TIMES	2 db 0
score:
	TIMES	2 db 0
tmpCmd:
	TIMES	8 db 0
